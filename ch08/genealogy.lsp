;#!/usr/local/bin/clisp

;;
;   NAME:               genealogy.lsp
;
;   STARTED:            010429
;   MODIFICATIONS:
;
;   PURPOSE:
;
;
;
;   CALLING SEQUENCE:
;
;
;   INPUTS:
;
;   OUTPUTS:
;
;   EXAMPLE:
;
;   NOTES:
;
;;
(defvar *family*
      '((colin nil nil)
        (deirdre nil nil)
        (arthur nil nil)
        (kate nil nil)
        (frank nil nil)
        (linda nil nil)
        (suzanne colin deirdre)
        (bruce arthur kate)
        (charles arthur kate)
        (david arthur kate)
        (ellen arthur kate)
        (george frank linda)
        (hillary frank linda)
        (andre nil nil)
        (tamara bruce suzanne)
        (vincent bruce suzanne)
        (wanda nil nil)
        (ivan george ellen)
        (julie george ellen)
        (marie george ellen)
        (nigel andre hillary)
        (frederick nil tamara)
        (zelda vincent wanda)
        (joshua ivan wanda)
        (quentin nil nil)
        (robert quentin julie)
        (olivia nigel marie)
        (peter nigel marie)
        (erica nil nil)
        (yvette robert zelda)
        (diane peter erica)))

(defun father (person)
  (cond ((null person) nil)
	(t (second (assoc person *family*)))) )



(defun mother (person)
  (cond ((null person) nil)
	(t (third (assoc person *family*)))) )



; (defun parents (person)
;   (cond ((null person) nil)
; 	(t (remove nil (list (father person)           ;Any better way to do this?
; 			     (mother person)))) ) )

;;  Yes.
(defun parents (person)
  (cond ((null person) nil)
	(t (let ((dad (father person))
		 (mom (mother person)))
	     (append (and dad (list dad))
		     (and mom (list mom)))) )) )


;;    (See Touretzky's CHEAP solution!)
(defun children (parent)
  (cond ((null parent) nil)
	(t (children-aux parent *family*))) )

(defun children-aux (parent family)
  (let ((person (caar family)))
    (cond ((null family) nil)
	  ((or (equal parent (father person))        ;OR (member parent (parents person))
	       (equal parent (mother person)))       ;
	   (cons person (children-aux parent (rest family))))
	  (t (children-aux parent (rest family)))) ) )



;;    Touretzky's solution here is kind of slick. Plus it makes use of just-defined functions.
;;    (Mine is slick too! It makes use of RECURSION!)
(defun siblings (child)
  (cond ((null child) nil)
	(t (let ((mom (mother child))
		 (pop (father child)))
	     (siblings-aux child mom pop *family*)))) )

(defun siblings-aux (child mom pop family)
  (let ((person (caar family)))
    (cond ((null family) nil)
	  ((equal person child) (siblings-aux child mom pop (rest family)))
	  ((or (equal mom (mother person))
	       (equal pop (father person)))
	   (cons person (siblings-aux child mom pop (rest family))))
	  (t (siblings-aux child mom pop (rest family)))) ) )

;;;
;;;    Take the union of the sets generated by applying a function f
;;;    to each element of a list l.
;;;
(defun mapunion (f l)
  (reduce #'union (mapcar f l)) )

(defun grandparents (grandchild)
  (mapunion #'parents (parents grandchild)) )

(defun cousins (person)
  (mapunion #'children 
	    (mapunion #'siblings (parents person))) )



(defun descended-from (descendent ancestor)
  (cond ((null descendent) nil)
	((member ancestor (parents descendent)) t)
	(t (or (descended-from (father descendent) ancestor)
	       (descended-from (mother descendent) ancestor)))) )



(defun ancestors (person)
  (cond ((null person) nil)
	(t (union (parents person)           ;The need for UNION here occurs if a parent mates with a child. Then
                                             ; the grandchild has a parent who is also his grandparent (his parent's parent).
		  (union (ancestors (father person))        ; UNION is required here for cases such as Yvette. Her 
			 (ancestors (mother person)))) )) ) ; parents have common ancestors.

;    My original. Touretzky uses UNION above.
; (defun ancestors (person)
;   (cond ((null person) nil)
; 	(t (append (parents person) 
; 		   (ancestors (father person))
; 		   (ancestors (mother person)))) ) )
		   
	       
;Compare Touretzky's version
(defun generation-gap (descendent ancestor)
  (cond ((not (descended-from descendent ancestor)) nil)
	(t (generation-gap-aux descendent ancestor))) )

(defun generation-gap-aux (descendent ancestor)
  (cond ((member ancestor (parents descendent)) 1)
	((descended-from (father descendent) ancestor)
	 (1+ (generation-gap-aux (father descendent) ancestor)))
	(t (1+ (generation-gap-aux (mother descendent) ancestor)))) )
